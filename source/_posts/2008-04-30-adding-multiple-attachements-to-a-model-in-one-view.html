---
layout: post
title: Adding Multiple Attachements to a Model in one View
tags:
- Code
- Rails
- Ruby
status: publish
type: post
published: true
meta:
  _edit_last: '2'
---
AttachmentFu is a great plugin. It's heavily used all over the place to upload images to a Rails app. It's also good with other file types.

I had a requirement to provide users with the ability to set up an entity (call it a Batch), then upload a number of CSV files to that batch. I used AttachmentFu, FasterCSV, and some Multi-Model editing forms to make the trickery work.

Before starting, I set up the AttachmentFu plugin. If you have never done this before, <a href="http://clarkware.com/cgi/blosxom/2007/02/24#FileUploadFu"> Mike Clark's Tutorial</a> is a good place to start. Install the plugin and take note of how you have to set up your Attachment model.

Then, I had to set up a Multi-model editing form. If you haven't done this before, then you should read Ryan Bates' tutorial on <a href="http://railsforum.com/viewtopic.php?pid=3713"> setting up multiple models in one view</a>.  In this situation, I had to modify some of the steps because we're dealing with File Attachments, not Task objects. Here is what I did:

First I created my "Batch" object.
<pre lang="bash" line="1">
script/generate migration Batch user_id:integer name:string
</pre>

Then I created my "Attachment" object.
<pre lang="bash" line="1">
script/generate migration Attachment
</pre>

I use Oracle. In order to make AttachmentFu work, I renamed "size" to "filesize"
<pre lang="ruby" line="1">
... In 002_create_attachment.rb
def self.up
  create_table :attachments do |t|
  t.integer    :parent_id # foreign key to :batches
  t.string     :content_type, :filename, :thumbnail
  t.integer    :filesize, :width, :height
end
</pre>

Then, in my Batch model, I added the Multi-Model handling code.  My method differs from the Rails Recipe because you cannot update an attachment once you upload it, only delete it. In the Update action, for each attachment on the model, we check to see where there is an attribute containing the ID of the attachment
<pre lang="ruby" line="1">
# If there is not an ID in an attribute, we delete the attachment.
# ... In batch.rb
has_many   :attachments, :foreign_key =&gt; "parent_id", :dependent =&gt; :destroy
validates_associated    :attachments

def new_attachment_attributes=(attrs)
  attrs.each { |attr| attachments.build(attr) }
end

def existing_attachment_attributes=(attrs)
  attachments.reject(&amp;:new_record?).each do |attach|
    attachments.delete(attach) unless attrs[attach.id.to_s]
  end
end

def save_attachments
  attachments.each { |attach| attach.save(false) }
end
</pre>

Then I set up the Attachment model to handle the AttachmentFu-ery.

<pre lang="ruby" line="1">
class Attachment < ActiveRecord::Base
  belongs_to     :batch
  has_attachment :storage =&gt; :file_system     # Or S3, or DB, or whatever
  validates_as_attachment

  ## Patch to make this AttachmentFu Model object work with Oracle.
  def size
    self.filesize
  end

  def size=(bytes)
    self.filesize = bytes
  end
end
</pre>

Now I needed to build the view and controller support. To keep the app mostly RESTful, we let the standard "Attachment" controller be built by the scaffolding system. Since we will be primarily working with Attachments in the "Batch" view, though, I've omitted those details.

Here is the additional controller code in batch_controller.rb:

<pre lang="ruby" line="1">
# GET /batches/new
def new
  @batch = Batch.new
  @batch.attachments.build
end

def update
  params[:batch][:existing_attachment_attributes] ||= {}

  @batch = Batch.find(params[:id])

  respond_to do |format|
    if @batch.update_attributes(params[:batch])
       flash[:notice] = 'Your Batch was updated successfully.'
       format.html { redirect_to batch_url(@batch) }
       format.xml  { head :ok }
    else
       format.html { render :action =&gt; "edit" }
       format.xml  { render :xml =&gt; @batch.errors.to_xml }
    end
  end
end
</pre>
What's left? Setting up the views. We leave the scaffolded "index" action for the Batch view in place. Attachments aren't relevant in that view. But in the "Edit" and "New" views, we need to create a custom form that can handle attaching files in addition to setting up the Batch model object.

Step 1, make the Edit and New actions point to a shared form:

<pre lang="html" line="1">
<!-- Contents of views/batches/new.html.erb
and views/batches/edit.html.erb
-->
<div class="greybox"><%= render :partial =>; 'form' %></div>
</pre>
Then, we set up the shared form in a partial like so:

<pre lang="html" line="1">
<h1>Schedule A Batch</h1>
<!-- views/batches/_form.html.erb: error display code omitted -->
  <% form_for(@batch, :html => { :multipart => true }) do |f| %>
  <strong>Name:</strong> <%= f.text_field :name %>
  <div id="attachments"><%= render :partial => "attachment", :collection =>  
  @batch.attachments%></div>
  <%= add_attachment_link "Add a File" %>
  Total Line Count: <%= @batch.prod_line_count %>

  <input name="batch[user_id]" type="hidden" value="<%= @user.id %>" />

  <%= submit_tag "Save Changes" %&gt; or &lt;%= link_to 'Cancel', batches_path %>

  <% end %>
</pre>

The code above renders the primary Model object, and then renders the associated attachments using the "_attachment" partial. Let's take a look at that code:

<pre lang="html" line="1">
<div id="attachments" class="attachment"><% new_or_existing = attachment.new_record? ? 'new' : 'existing' %>
  <% prefix = "batch[#{new_or_existing}_attachment_attributes][]" %>
  <% fields_for prefix, attachment do |af| -%>

  <strong>Attached File:</strong>
  <% if attachment.new_record? %>


  <%= af.file_field :uploaded_data %>
  <% else %>
  <%= af.hidden_field :id %>
  <%= attachment.filename %>
  <%= link_to_function "remove", "$(this).up('.attachment').remove()" unless params[:action] == "show"%>
  <% end %>

  <% end -%>
</div>
</pre>
This sets the front end up to show the attached files, and provide a link to delete each on on the front end using javascript (unless we are being rendered in the "show" action. We'll refactor that piece of bad juju later).

The last piece of work to do is to set up the "show" action to display the child records. This isn't hard. There is no need to modify the default scaffolded view. Just add the partial to show the attachments:

<pre lang="html" line="1">
<-- Add to views/batches/show.html.erb -->
<div id="attachments"><%= render :partial => "attachment", :collection => @batch.attachments%></div>
</pre>

That's it. You still have an application that responds RESTfully to Batch and Attachment requests, but when you are a person in front of a browser, you can attach multiple files to your Batch object.
